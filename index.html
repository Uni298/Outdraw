<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QuickDraw CNN Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          "Comic Sans MS", "Chalkboard SE", "Comic Neue", cursive, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
        padding: 15px 10px;
        min-height: 100vh;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
      }

      h1 {
        font-size: 36px;
        font-weight: 700;
        margin-bottom: 4px;
        color: #ffeb3b;
        text-shadow:
          3px 3px 0px #ff4081,
          5px 5px 0px #7c4dff;
        letter-spacing: 2px;
      }

      .subtitle {
        font-size: 15px;
        color: #ffd54f;
        margin-bottom: 15px;
        font-weight: 600;
      }

      #loadingScreen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      #loadingScreen.hidden {
        display: none;
      }

      .loading-content {
        text-align: center;
        max-width: 400px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        border: 3px solid #ffeb3b;
      }

      .loading-title {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: 15px;
        color: #ffeb3b;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.3);
        margin-bottom: 10px;
        overflow: hidden;
        border-radius: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff4081, #ffeb3b, #00e676);
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 10px;
      }

      .loading-text {
        font-size: 14px;
        color: #ffffff;
        font-weight: 600;
      }

      #canvasWrapper {
        border: 5px solid #ff4081;
        display: inline-block;
        background: #ffffff;
        margin-bottom: 12px;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      }

      canvas {
        background: #ffffff;
        cursor: crosshair;
        display: block;
      }

      .controls {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
        font-weight: 700;
        background: linear-gradient(135deg, #ff4081, #f50057);
        color: #ffffff;
        border: 3px solid #ffffff;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        border-radius: 25px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        text-transform: uppercase;
      }

      button:hover {
        background: linear-gradient(135deg, #7c4dff, #536dfe);
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
      }

      button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }

      button:disabled {
        background: #9e9e9e;
        color: #e0e0e0;
        border-color: #757575;
        cursor: not-allowed;
        transform: none;
      }

      button:disabled:hover {
        background: #9e9e9e;
        transform: none;
      }

      #results {
        border-top: 3px solid #ffeb3b;
        padding-top: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 15px;
        margin-top: 10px;
      }

      h2 {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 10px;
        color: #ffeb3b;
        text-shadow: 2px 2px 0px #ff4081;
      }

      #output {
        font-size: 15px;
        line-height: 1.4;
      }

      .result-main {
        font-size: 18px;
        margin-bottom: 5px;
        font-weight: 700;
        color: #00e676;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .result-score {
        font-size: 14px;
        color: #ffd54f;
        margin-bottom: 10px;
        font-weight: 600;
      }

      .top-predictions {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 2px solid rgba(255, 255, 255, 0.3);
      }

      .top-predictions-title {
        font-size: 16px;
        font-weight: 700;
        margin-bottom: 8px;
        color: #ffeb3b;
      }

      .prediction {
        padding: 5px 8px;
        font-size: 14px;
        color: #ffffff;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        margin-bottom: 3px;
        border-radius: 8px;
      }

      .prediction:last-child {
        border-bottom: none;
      }

      .prediction-rank {
        display: inline-block;
        width: 30px;
        color: #ff4081;
        font-weight: 700;
      }

      .prediction-name {
        font-weight: 600;
        color: #ffffff;
      }

      .prediction-score {
        color: #ffd54f;
        float: right;
        font-weight: 600;
      }

      .error {
        color: #ff1744;
        padding: 10px;
        border: 2px solid #ff1744;
        background: rgba(255, 23, 68, 0.2);
        margin-top: 8px;
        border-radius: 10px;
        font-weight: 600;
      }

      /* Chat Box Styles */
      #chatBox {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 320px;
        height: 400px;
        background: linear-gradient(135deg, #7c4dff, #536dfe);
        border: 4px solid #ffeb3b;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        z-index: 999;
      }

      #chatHeader {
        background: linear-gradient(135deg, #ff4081, #f50057);
        color: #ffffff;
        padding: 10px 15px;
        font-weight: 700;
        font-size: 18px;
        text-align: center;
        border-bottom: 3px solid #ffeb3b;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }

      #chatMessages {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
      }

      .chat-message {
        margin-bottom: 8px;
        padding: 8px 12px;
        border-radius: 15px;
        font-size: 13px;
        line-height: 1.4;
        word-wrap: break-word;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-message.user {
        background: linear-gradient(135deg, #00e676, #00c853);
        color: #ffffff;
        margin-left: 20px;
        text-align: right;
        font-weight: 600;
      }

      .chat-message.other {
        background: rgba(255, 255, 255, 0.9);
        color: #333333;
        margin-right: 20px;
        font-weight: 600;
      }

      .chat-message .username {
        font-weight: 700;
        font-size: 11px;
        margin-bottom: 3px;
        opacity: 0.8;
      }

      #chatInputArea {
        display: flex;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-top: 3px solid #ffeb3b;
        gap: 5px;
      }

      #chatInput {
        flex: 1;
        padding: 8px 12px;
        border: 2px solid #ffffff;
        border-radius: 20px;
        font-size: 14px;
        font-family: inherit;
        background: #ffffff;
        color: #333333;
        font-weight: 600;
      }

      #chatInput:focus {
        outline: none;
        border-color: #ffeb3b;
        box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
      }

      #chatSendBtn {
        padding: 8px 16px;
        background: linear-gradient(135deg, #ffeb3b, #ffc107);
        color: #333333;
        border: 2px solid #ffffff;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 700;
        font-size: 14px;
        transition: all 0.2s ease;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
      }

      #chatSendBtn:hover {
        background: linear-gradient(135deg, #00e676, #00c853);
        color: #ffffff;
        transform: scale(1.05);
      }

      #chatSendBtn:active {
        transform: scale(0.95);
      }

      @media (max-width: 600px) {
        body {
          padding: 10px 8px;
        }

        h1 {
          font-size: 28px;
        }

        #canvasWrapper {
          width: 100%;
        }

        canvas {
          width: 100%;
          height: auto;
        }

        #chatBox {
          width: 280px;
          height: 350px;
          bottom: 10px;
          right: 10px;
        }
      }
    </style>
  </head>

  <body>
    <div id="loadingScreen">
      <div class="loading-content">
        <div class="loading-title">„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô...</div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="loading-text" id="loadingText">Ê∫ñÂÇô‰∏≠...</div>
      </div>
    </div>

    <div class="container">
      <h1>QuickDraw CNN Demo</h1>
      <div class="subtitle">
        „Ç≠„É£„É≥„Éê„Çπ„Å´Áµµ„ÇíÊèè„ÅÑ„Å¶„ÄÅAI„Å´‰Ωï„ÇíÊèè„ÅÑ„Åü„ÅãÂΩì„Å¶„Å¶„ÇÇ„Çâ„ÅÑ„Åæ„Åó„Çá„ÅÜ
      </div>

      <div id="canvasWrapper">
        <canvas id="draw" width="400" height="400"></canvas>
      </div>

      <div class="controls">
        <button id="clearBtn">„ÇØ„É™„Ç¢</button>
        <button id="predictBtn">‰∫àÊ∏¨„Åô„Çã</button>
      </div>

      <div id="results">
        <h2>‰∫àÊ∏¨ÁµêÊûú</h2>
        <div id="output">
          „Ç≠„É£„É≥„Éê„Çπ„Å´‰Ωï„ÅãÊèè„ÅÑ„Å¶„Äå‰∫àÊ∏¨„Åô„Çã„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ
        </div>
      </div>
    </div>

  <!-- Chat Box -->
  <div id="chatBox">
    <div id="chatHeader">üí¨ „ÉÅ„É£„ÉÉ„Éà</div>
    <div id="chatMessages"></div>
    <div id="chatInputArea">
      <input type="text" id="chatInput" placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ..." />
      <button id="chatSendBtn">ÈÄÅ‰ø°</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
      // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
      let session = null;
      let modelNames = [];
      const canvas = document.getElementById("draw");
      const ctx = canvas.getContext("2d");
      const clearBtn = document.getElementById("clearBtn");
      const predictBtn = document.getElementById("predictBtn");
      const output = document.getElementById("output");
      const loadingScreen = document.getElementById("loadingScreen");
      const progressFill = document.getElementById("progressFill");
      const loadingText = document.getElementById("loadingText");

      // ÊèèÁîªË®≠ÂÆö
      ctx.lineWidth = 12;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "#000000";

      let drawing = false;
      let currentStroke = null;
      let strokes = [];

      // ===== „É¢„Éá„É´Ë™≠„ÅøËæº„Åø =====
      async function loadModel() {
        try {
          // „Ç´„ÉÜ„Ç¥„É™Ë™≠„ÅøËæº„Åø
          progressFill.style.width = "20%";
          loadingText.textContent = "„Ç´„ÉÜ„Ç¥„É™„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô...";

          const categoriesUrl =
            "https://raw.githubusercontent.com/Uni298/Outdraw/refs/heads/main/categories.txt";
          const catResponse = await fetch(categoriesUrl);
          const catText = await catResponse.text();
          modelNames = catText
            .split(/\r?\n/)
            .map((s) => s.trim())
            .filter((s) => s.length > 0);
          console.log(`„Ç´„ÉÜ„Ç¥„É™Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü: ${modelNames.length}ÂÄã`);

          // ONNX„É¢„Éá„É´Êú¨‰Ωì„Å®Â§ñÈÉ®„Éá„Éº„Çø„ÇíÂèñÂæó
          progressFill.style.width = "40%";
          loadingText.textContent = "ONNX„É¢„Éá„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶„ÅÑ„Åæ„Åô...";

          const modelUrl =
            "https://raw.githubusercontent.com/Uni298/Outdraw/main/png_model_32/model.onnx";
          const dataUrl = modelUrl + ".data"; // Âêå„Åò„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´„ÅÇ„ÇãÂ§ñÈÉ®„Éá„Éº„Çø

          // ‰∏¶Âàó„ÅßÂèñÂæó„Åó„ÄÅ„Å©„Å°„Çâ„Åã„ÅåÂ§±Êïó„Åó„Å¶„ÇÇ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Åß„Åç„Çã„Çà„ÅÜ„Å´ÂÄãÂà•„Å´„ÉÅ„Çß„ÉÉ„ÇØ
          const [modelResp, dataResp] = await Promise.all([
            fetch(modelUrl),
            fetch(dataUrl).catch(() => null), // .data „ÅåÁÑ°„ÅÑÂ†¥Âêà„ÅØ null „ÇíË®±ÂÆπ
          ]);

          if (!modelResp.ok) {
            throw new Error(
              `„É¢„Éá„É´„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${modelResp.status}`,
            );
          }
          const modelBuffer = await modelResp.arrayBuffer();

          // .data „ÅåÂ≠òÂú®„Åô„Çå„Å∞ÂèñÂæó„Åó„Å¶‰øùÊåÅÔºàÂÆüÈöõ„ÅÆÊé®Ë´ñ„Å´ÂøÖË¶Å„Å™Â†¥Âêà„ÅØ ort „ÅåËá™Âãï„ÅßÂèÇÁÖßÔºâ
          let modelDataBuffer = null;
          if (dataResp && dataResp.ok) {
            modelDataBuffer = await dataResp.arrayBuffer();
            console.log(
              "Â§ñÈÉ®„Éá„Éº„Çø (model.onnx.data) „ÇíÂèñÂæó„Åó„Åæ„Åó„Åü„ÄÇ„Çµ„Ç§„Ç∫:",
              modelDataBuffer.byteLength,
            );
          } else {
            console.warn(
              "Â§ñÈÉ®„Éá„Éº„Çø (model.onnx.data) „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„É¢„Éá„É´„ÅåÂüã„ÇÅËæº„Åø„Éá„Éº„Çø„ÅÆ„Åø„ÅÆÂ†¥Âêà„ÅØÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
            );
          }

          progressFill.style.width = "70%";
          loadingText.textContent = "„É¢„Éá„É´„Éá„Éº„Çø„ÇíÂá¶ÁêÜ„Åó„Å¶„ÅÑ„Åæ„Åô...";

          // ort.InferenceSession.create „ÅØ ArrayBuffer „ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åô„ÄÇ
          // Â§ñÈÉ®„Éá„Éº„Çø„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÂêå„Åò„Éê„ÉÉ„Éï„Ç°„Å´ÁµêÂêà„Åô„ÇãÂøÖË¶Å„ÅØ„Å™„Åè„ÄÅ
          // Web Áí∞Â¢É„Åß„ÅØÂÜÖÈÉ®„Åß fetch „Åó„Å¶ÂèñÂæó„Åß„Åç„Çã„ÅÆ„Åß„Åù„ÅÆ„Åæ„ÅæÊ∏°„Åó„Åæ„Åô„ÄÇ
          session = await ort.InferenceSession.create(modelBuffer);

          progressFill.style.width = "100%";
          loadingText.textContent = "ÂÆå‰∫Ü!";
          console.log("ONNX„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü");

          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 500);
        } catch (err) {
          console.error("„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:", err);
          loadingText.textContent = "„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: " + err.message;
          loadingText.style.color = "#cc0000";
        }
      }

      // ===== ÊèèÁîªÈñ¢Êï∞ =====
      function drawLine(grid, x0, y0, x1, y1, size) {
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = x0 < x1 ? 1 : -1;
        let sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
          if (x0 >= 0 && x0 < size && y0 >= 0 && y0 < size) {
            grid[y0][x0] = 0;
          }
          if (x0 === x1 && y0 === y1) break;
          let e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x0 += sx;
          }
          if (e2 < dx) {
            err += dx;
            y0 += sy;
          }
        }
      }

      function normalizeStrokes(strokes, size = 32) {
        let xs = [];
        let ys = [];

        for (const stroke of strokes) {
          xs.push(...stroke[0]);
          ys.push(...stroke[1]);
        }

        if (xs.length === 0 || ys.length === 0) return [];

        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const w = maxX - minX + 1e-5;
        const h = maxY - minY + 1e-5;

        const normalized = strokes.map((stroke) => [
          stroke[0].map((x) => Math.floor(((x - minX) / w) * (size - 1))),
          stroke[1].map((y) => Math.floor(((y - minY) / h) * (size - 1))),
        ]);

        return normalized;
      }

      function rasterizeStrokes(strokes, size = 32) {
        const normalizedStrokes = normalizeStrokes(strokes, size);
        const grid = Array(size)
          .fill()
          .map(() => Array(size).fill(255));

        for (const stroke of normalizedStrokes) {
          const xs = stroke[0];
          const ys = stroke[1];
          for (let i = 0; i < xs.length - 1; i++) {
            drawLine(grid, xs[i], ys[i], xs[i + 1], ys[i + 1], size);
          }
        }

        const data = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            data.push(1.0 - grid[y][x] / 255.0);
          }
        }
        return data;
      }

      // ===== ‰∫àÊ∏¨Èñ¢Êï∞ =====
      async function predictStrokes(strokes, options = {}) {
        if (!session) {
          throw new Error("„É¢„Éá„É´„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì");
        }

        const size = 32;
        const topNCount = options.topN || 10;

        const imgArray = rasterizeStrokes(strokes, size);
        const inputTensor = new ort.Tensor(
          "float32",
          Float32Array.from(imgArray),
          [1, 1, size, size],
        );

        const results = await session.run({ input: inputTensor });
        const logits = results.logits.data;

        const numClasses = logits.length;
        const scored = [];
        for (let i = 0; i < numClasses; i++) {
          scored.push({
            index: i,
            score: logits[i],
            name: modelNames[i] || `class_${i}`,
          });
        }

        scored.sort((a, b) => b.score - a.score);

        const topN = scored.slice(0, topNCount);
        const best = scored[0];

        return {
          classIndex: best.index,
          className: best.name,
          score: best.score,
          topN: topN,
        };
      }

      // ===== „Ç≠„É£„É≥„Éê„ÇπÊìç‰Ωú =====
      function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = ((e.clientX || e.touches[0].clientX) - rect.left) * scaleX;
        const y = ((e.clientY || e.touches[0].clientY) - rect.top) * scaleY;
        return { x, y };
      }

      function startDraw(e) {
        e.preventDefault();
        drawing = true;
        const pos = getCanvasPos(e);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);

        currentStroke = [[], []];
        currentStroke[0].push(pos.x);
        currentStroke[1].push(pos.y);
      }

      function moveDraw(e) {
        if (!drawing) return;
        e.preventDefault();
        const pos = getCanvasPos(e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();

        currentStroke[0].push(pos.x);
        currentStroke[1].push(pos.y);
      }

      function endDraw(e) {
        if (!drawing) return;
        e.preventDefault();
        drawing = false;
        if (currentStroke && currentStroke[0].length > 0) {
          strokes.push(currentStroke);
        }
        currentStroke = null;
      }

      // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
      canvas.addEventListener("mousedown", startDraw);
      canvas.addEventListener("mousemove", moveDraw);
      canvas.addEventListener("mouseup", endDraw);
      canvas.addEventListener("mouseleave", endDraw);

      canvas.addEventListener("touchstart", startDraw);
      canvas.addEventListener("touchmove", moveDraw);
      canvas.addEventListener("touchend", endDraw);
      canvas.addEventListener("touchcancel", endDraw);

      // „ÇØ„É™„Ç¢„Éú„Çø„É≥
      clearBtn.addEventListener("click", () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        strokes = [];
        output.innerHTML =
          "„Ç≠„É£„É≥„Éê„Çπ„Å´‰Ωï„ÅãÊèè„ÅÑ„Å¶„Äå‰∫àÊ∏¨„Åô„Çã„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
      });

      // ÂàùÊúüËÉåÊôØ
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ‰∫àÊ∏¨„Éú„Çø„É≥
      predictBtn.addEventListener("click", async () => {
        if (strokes.length === 0) {
          output.innerHTML = '<div class="error">‰Ωï„ÅãÊèè„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ</div>';
          return;
        }

        try {
          output.innerHTML = "‰∫àÊ∏¨‰∏≠...";
          predictBtn.disabled = true;

          const result = await predictStrokes(strokes, { topN: 10 });

          let html = "";
          html += `<div class="result-main">‰∫àÊ∏¨: <strong>${result.className}</strong></div>`;
          html += `<div class="result-score">„Çπ„Ç≥„Ç¢: ${result.score.toFixed(3)}</div>`;

          html += '<div class="top-predictions">';
          html += '<div class="top-predictions-title">‰∏ä‰Ωç10‰ª∂„ÅÆ‰∫àÊ∏¨</div>';

          result.topN.forEach((item, idx) => {
            html += `<div class="prediction">`;
            html += `<span class="prediction-rank">#${idx + 1}</span>`;
            html += `<span class="prediction-name">${item.name}</span>`;
            html += `<span class="prediction-score">${item.score.toFixed(3)}</span>`;
            html += `</div>`;
          });

          html += "</div>";

          output.innerHTML = html;
        } catch (err) {
          console.error(err);
          output.innerHTML =
            '<div class="error">„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' +
            err.message +
            "</div>";
        } finally {
          predictBtn.disabled = false;
        }
      });

    // ===== „ÉÅ„É£„ÉÉ„ÉàÊ©üËÉΩ =====
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');

    // „Éá„É¢Áî®„ÅÆ„É¶„Éº„Ç∂„ÉºÂêç
    const currentUser = '„ÅÇ„Å™„Åü';

    // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíËøΩÂä†„Åô„ÇãÈñ¢Êï∞
    function addChatMessage(username, message, isCurrentUser = false) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${isCurrentUser ? 'user' : 'other'}`;
      
      if (!isCurrentUser) {
        const usernameSpan = document.createElement('div');
        usernameSpan.className = 'username';
        usernameSpan.textContent = username;
        messageDiv.appendChild(usernameSpan);
      }
      
      const messageText = document.createElement('div');
      messageText.textContent = message;
      messageDiv.appendChild(messageText);
      
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
    function sendMessage() {
      const message = chatInput.value.trim();
      if (message === '') return;
      
      addChatMessage(currentUser, message, true);
      chatInput.value = '';
      
      // „Éá„É¢Áî®: „É©„É≥„ÉÄ„É†„Å™Ëá™ÂãïËøî‰ø°
      setTimeout(() => {
        const responses = [
          '„Åô„Åî„ÅÑÁµµ„Å†„Å≠!',
          '„Åù„Çå„ÅØ‰Ωï„ÇíÊèè„ÅÑ„Åü„ÅÆ?',
          '„ÅÜ„Åæ„ÅèÊèè„Åë„Å¶„Çã„Å≠!',
          'AI„ÅÆ‰∫àÊ∏¨„ÅØÂΩì„Åü„Å£„Åü?',
          '„ÇÇ„Å£„Å®Êèè„ÅÑ„Å¶Ë¶ã„Åõ„Å¶!'
        ];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        addChatMessage('„Éó„É¨„Ç§„É§„Éº' + Math.floor(Math.random() * 100), randomResponse, false);
      }, 1000 + Math.random() * 2000);
    }

    chatSendBtn.addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });

    // „Ç¶„Çß„É´„Ç´„É†„É°„ÉÉ„Çª„Éº„Ç∏
    addChatMessage('„Ç∑„Çπ„ÉÜ„É†', '„ÉÅ„É£„ÉÉ„Éà„Å∏„Çà„ÅÜ„Åì„Åù! Ëá™Áî±„Å´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ„Å£„Å¶„Å≠!', false);

      // Ëµ∑ÂãïÊôÇ„Å´„É¢„Éá„É´Ë™≠„ÅøËæº„Åø
      loadModel();
    </script>
  </body>
</html>
