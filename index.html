<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QuickDraw CNN Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff;
      color: #000000;
      padding: 40px 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #000000;
    }

    .subtitle {
      font-size: 14px;
      color: #666666;
      margin-bottom: 40px;
    }

    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #loadingScreen.hidden {
      display: none;
    }

    .loading-content {
      text-align: center;
      max-width: 400px;
      padding: 20px;
    }

    .loading-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #000000;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #e0e0e0;
      margin-bottom: 12px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #000000;
      width: 0%;
      transition: width 0.3s ease;
    }

    .loading-text {
      font-size: 13px;
      color: #666666;
    }

    #canvasWrapper {
      border: 2px solid #000000;
      display: inline-block;
      background: #ffffff;
      margin-bottom: 20px;
    }

    canvas {
      background: #ffffff;
      cursor: crosshair;
      display: block;
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 40px;
    }

    button {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 500;
      background: #000000;
      color: #ffffff;
      border: 2px solid #000000;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    button:hover {
      background: #ffffff;
      color: #000000;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      background: #e0e0e0;
      color: #999999;
      border-color: #e0e0e0;
      cursor: not-allowed;
    }

    button:disabled:hover {
      background: #e0e0e0;
      color: #999999;
    }

    #results {
      border-top: 2px solid #000000;
      padding-top: 30px;
    }

    h2 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #000000;
    }

    #output {
      font-size: 14px;
      line-height: 1.6;
    }

    .result-main {
      font-size: 16px;
      margin-bottom: 8px;
      font-weight: 600;
      color: #000000;
    }

    .result-score {
      font-size: 13px;
      color: #666666;
      margin-bottom: 20px;
    }

    .top-predictions {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #e0e0e0;
    }

    .top-predictions-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #000000;
    }

    .prediction {
      padding: 8px 0;
      font-size: 13px;
      color: #333333;
      border-bottom: 1px solid #f0f0f0;
    }

    .prediction:last-child {
      border-bottom: none;
    }

    .prediction-rank {
      display: inline-block;
      width: 30px;
      color: #999999;
    }

    .prediction-name {
      font-weight: 500;
      color: #000000;
    }

    .prediction-score {
      color: #666666;
      float: right;
    }

    .error {
      color: #cc0000;
      padding: 12px;
      border: 1px solid #cc0000;
      background: #fff5f5;
      margin-top: 12px;
    }

    @media (max-width: 600px) {
      body {
        padding: 20px 16px;
      }

      h1 {
        font-size: 24px;
      }

      #canvasWrapper {
        width: 100%;
      }

      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>

<body>
  <div id="loadingScreen">
    <div class="loading-content">
      <div class="loading-title">モデルを読み込んでいます...</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="loading-text" id="loadingText">準備中...</div>
    </div>
  </div>

  <div class="container">
    <h1>QuickDraw CNN Demo</h1>
    <div class="subtitle">
      キャンバスに絵を描いて、AIに何を描いたか当ててもらいましょう
    </div>

    <div id="canvasWrapper">
      <canvas id="draw" width="400" height="400"></canvas>
    </div>

    <div class="controls">
      <button id="clearBtn">クリア</button>
      <button id="predictBtn">予測する</button>
    </div>

    <div id="results">
      <h2>予測結果</h2>
      <div id="output">
        キャンバスに何か描いて「予測する」ボタンを押してください
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    // グローバル変数
    let session = null;
    let modelNames = [];
    const canvas = document.getElementById("draw");
    const ctx = canvas.getContext("2d");
    const clearBtn = document.getElementById("clearBtn");
    const predictBtn = document.getElementById("predictBtn");
    const output = document.getElementById("output");
    const loadingScreen = document.getElementById("loadingScreen");
    const progressFill = document.getElementById("progressFill");
    const loadingText = document.getElementById("loadingText");

    // 描画設定
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#000000";

    let drawing = false;
    let currentStroke = null;
    let strokes = [];

    // ============================================
    // 1. モデル読み込み (Local)
    // ============================================
    async function loadModel() {
      try {
        // カテゴリ読み込み
        progressFill.style.width = "20%";
        loadingText.textContent = "カテゴリを読み込んでいます...";

        // ローカルの categories.txt (public/categories.txt がある前提、またはルート)
        // ディレクトリ構成によるとルートにあると思われるが、
        // サーバーのルートがどこかによる。ここでは相対パス './categories.txt' を試す。
        const categoriesUrl = "./categories.txt";
        const catResponse = await fetch(categoriesUrl);
        if (!catResponse.ok) throw new Error(`Categories file not found: ${categoriesUrl}`);
        const catText = await catResponse.text();
        modelNames = catText
          .split(/\r?\n/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        console.log(`カテゴリ読み込み完了: ${modelNames.length}個`);

        // ONNXモデル本体
        progressFill.style.width = "40%";
        loadingText.textContent = "ONNXモデルをダウンロードしています...";

        // ローカルの ./png_model_32/model_fixed.onnx
        const modelUrl = "./png_model_64/model_fixed.onnx";

        // dataファイルがあるかどうか確認するのは難しいので fetch でトライ
        const dataUrl = modelUrl + ".data";

        const [modelResp, dataResp] = await Promise.all([
          fetch(modelUrl),
          fetch(dataUrl).catch(() => null),
        ]);

        if (!modelResp.ok) {
          throw new Error(`モデルが見つかりません: ${modelUrl}`);
        }
        const modelBuffer = await modelResp.arrayBuffer();

        if (dataResp && dataResp.ok) {
          // WebのORTでは外部データを自動でハンドリングしてくれる場合があるが、
          // 明示的に渡す必要がある場合は session options に渡すか、
          // model buffer と一緒に扱う必要がある。
          // 今回は単純に simple loading で行く（元のコードもそうだったため）
          // もし外部データが必要なら ort.env.wasm.numThreads などを調整するか
          // create の引数を変える必要があるかもしれません。
          console.log("外部データが見つかりました (今回は自動ロードに任せます)");
        }

        progressFill.style.width = "70%";
        loadingText.textContent = "モデルデータを処理しています...";

        // ONNX Runtime Web session creation
        session = await ort.InferenceSession.create(modelBuffer, {
          executionProviders: ['wasmgl', 'wasm'], // WebGL優先
          graphOptimizationLevel: 'all'
        });

        progressFill.style.width = "100%";
        loadingText.textContent = "完了!";
        console.log("ONNXモデル読み込み完了");
        if (session.executionProviders) {
          console.log(`Provider: ${session.executionProviders.join(', ')}`);
        } else {
          console.log("Provider info not available");
        }

        setTimeout(() => {
          loadingScreen.classList.add("hidden");
        }, 500);
      } catch (err) {
        console.error("モデル読み込みエラー:", err);
        loadingText.textContent = "エラー: " + err.message;
        loadingText.style.color = "#ff1744";
      }
    }

    // ============================================
    // 2. 描画・前処理ロジック (from cnn.js)
    // ============================================

    // 軽量アンチエイリアシング描画
    function rasterizeStrokesAA(strokes, size = 64) {
      // 2倍解像度で描画してダウンサンプリング
      const highRes = size * 2;

      // オフスクリーンキャンバス作成
      const offCanvas = document.createElement('canvas');
      offCanvas.width = highRes;
      offCanvas.height = highRes;
      const ctx = offCanvas.getContext('2d');

      // 背景白
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, highRes, highRes);

      let xs = [];
      let ys = [];
      for (const stroke of strokes) {
        xs.push(...stroke[0]);
        ys.push(...stroke[1]);
      }

      if (xs.length === 0 || ys.length === 0) {
        return new Array(size * size).fill(1.0); // 全部白(1.0) -> 反転前だが、後で1.0-valするなら0.0になる
      }

      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      const w = (maxX - minX) + 1e-5;
      const h = (maxY - minY) + 1e-5;

      // 描画設定
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      for (const stroke of strokes) {
        const pxs = stroke[0];
        const pys = stroke[1];

        const points = pxs.map((x, i) => ({
          x: ((x - minX) / w) * (highRes - 1),
          y: ((pys[i] - minY) / h) * (highRes - 1)
        }));

        if (points.length > 1) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }
      }

      // ダウンサンプリング
      const lowResCanvas = document.createElement('canvas');
      lowResCanvas.width = size;
      lowResCanvas.height = size;
      const lowResCtx = lowResCanvas.getContext('2d');

      lowResCtx.imageSmoothingEnabled = true;
      lowResCtx.imageSmoothingQuality = 'high';
      lowResCtx.drawImage(offCanvas, 0, 0, highRes, highRes, 0, 0, size, size);

      const imageData = lowResCtx.getImageData(0, 0, size, size);
      const pixels = imageData.data;

      const data = [];
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        // 黒(0)に近いほど描画されている。白(255)は背景。
        // モデルへの入力は 1.0 - (pixel/255) で、黒が1.0、白が0.0になるようにする
        // pixels[i] は RGB の R (グレースケールならどれでも同じ)
        data.push(1.0 - (r / 255.0));
      }

      return data;
    }

    // TTA (Test-Time Augmentation)
    function augmentStrokes(strokes, angle = 0, scale = 1.0) {
      if (angle === 0 && scale === 1.0) return strokes;

      const cos_a = Math.cos(angle * Math.PI / 180);
      const sin_a = Math.sin(angle * Math.PI / 180);

      // 中心を求めて回転させる簡易実装（本来は重心計算などがベターだが、cnn.js準拠で 127.5 を中心と仮定...できない）
      // cnn.js では 127.5 を引いているが、これは元の座標系が 0-255 である前提かもしれない。
      // Webキャンバスは 400x400 なので、中心は 200, 200 になる。
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // しかし、cnn.js の normalizeStrokes で 0-size に正規化される前の座標に対して行っているのか、
      // あるいは正規化後の座標か？
      // cnn.jsを見ると `predictWithTTA` 内で `augmentStrokes` してから `rasterizeStrokesAA` を呼んでいる。
      // `rasterizeStrokesAA` は生座標を受け取って内部で正規化(Bounding Boxフィット)している。
      // なので、ここでの `imgArray` 生成前の座標変換としては、
      // 「ストローク全体の重心」あるいは「キャンバス中心」を基準に回転させるのが妥当。
      // ここではキャンバス中心 (200,200) を基準にする。

      return strokes.map(stroke => {
        const xs = stroke[0];
        const ys = stroke[1];
        const new_xs = [];
        const new_ys = [];

        for (let i = 0; i < xs.length; i++) {
          const x = xs[i] - centerX;
          const y = ys[i] - centerY;

          const x_r = x * cos_a - y * sin_a;
          const y_r = x * sin_a + y * cos_a;

          new_xs.push(x_r * scale + centerX);
          new_ys.push(y_r * scale + centerY);
        }

        return [new_xs, new_ys];
      });
    }

    // 予測関数 (TTA付き)
    async function predictWithTTA(strokes, size = 64) {
      // TTAパターン
      const augmentations = [
        { angle: 0, scale: 1.0 },
        { angle: -5, scale: 1.0 },
        { angle: 5, scale: 1.0 },
        { angle: 0, scale: 0.95 },   // 少し縮小
        { angle: 0, scale: 1.05 }    // 少し拡大
      ];

      const allLogits = [];

      for (const aug of augmentations) {
        const augStrokes = augmentStrokes(strokes, aug.angle, aug.scale);
        const imgArray = rasterizeStrokesAA(augStrokes, size);

        const inputTensor = new ort.Tensor(
          'float32',
          Float32Array.from(imgArray),
          [1, 1, size, size]
        );

        const results = await session.run({ input: inputTensor });
        allLogits.push(results.logits.data);
      }

      const numClasses = allLogits[0].length;
      const avgLogits = new Float32Array(numClasses).fill(0);

      for (let i = 0; i < numClasses; i++) {
        for (let j = 0; j < allLogits.length; j++) {
          avgLogits[i] += allLogits[j][i];
        }
        avgLogits[i] /= allLogits.length;
      }

      return avgLogits;
    }

    async function predictStrokes(strokes, options = {}) {
      if (!session) throw new Error("モデルが読み込まれていません");

      const topNCount = options.topN || 10;

      // TTAを使って予測
      // 単発高速が良いなら TTA無し分岐も作れるが、PC/最近のスマホなら問題ないはず
      const logits = await predictWithTTA(strokes, 64);

      // Softmax & Sorting
      let scored = [];
      for (let i = 0; i < logits.length; i++) {
        scored.push({
          index: i,
          score: logits[i],
          name: modelNames[i] || `class_${i}`
        });
      }

      // 確率計算（Softmax）して confidence も出すとより良いが、今回はscore順だけでOK
      // Softmax
      let sumExp = 0;
      const exps = scored.map(s => Math.exp(s.score));
      sumExp = exps.reduce((a, b) => a + b, 0);
      scored.forEach((s, i) => {
        s.probability = exps[i] / sumExp;
      });

      scored.sort((a, b) => b.probability - a.probability);

      const topN = scored.slice(0, topNCount);
      const best = scored[0];

      return {
        className: best.name,
        score: best.score,
        probability: best.probability,
        topN: topN
      };
    }

    // ===== キャンバス操作 =====
    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = ((e.clientX || e.touches[0].clientX) - rect.left) * scaleX;
      const y = ((e.clientY || e.touches[0].clientY) - rect.top) * scaleY;
      return { x, y };
    }

    function startDraw(e) {
      e.preventDefault();
      drawing = true;
      const pos = getCanvasPos(e);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);

      currentStroke = [[], []];
      currentStroke[0].push(pos.x);
      currentStroke[1].push(pos.y);
    }

    function moveDraw(e) {
      if (!drawing) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();

      currentStroke[0].push(pos.x);
      currentStroke[1].push(pos.y);
    }

    function endDraw(e) {
      if (!drawing) return;
      e.preventDefault();
      drawing = false;
      if (currentStroke && currentStroke[0].length > 0) {
        strokes.push(currentStroke);
      }
      currentStroke = null;
    }

    // イベントリスナー
    canvas.addEventListener("mousedown", startDraw);
    canvas.addEventListener("mousemove", moveDraw);
    canvas.addEventListener("mouseup", endDraw);
    canvas.addEventListener("mouseleave", endDraw);

    canvas.addEventListener("touchstart", startDraw, { passive: false });
    canvas.addEventListener("touchmove", moveDraw, { passive: false });
    canvas.addEventListener("touchend", endDraw);
    canvas.addEventListener("touchcancel", endDraw);

    // クリアボタン
    clearBtn.addEventListener("click", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      strokes = [];
      output.innerHTML = "キャンバスに何か描いて「予測する」ボタンを押してください";
    });

    // 初期背景
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 予測ボタン
    predictBtn.addEventListener("click", async () => {
      if (strokes.length === 0) {
        output.innerHTML = '<div class="error">何か描いてください</div>';
        return;
      }

      try {
        output.innerHTML = "予測中... (TTA実行中)";
        predictBtn.disabled = true;

        const result = await predictStrokes(strokes, { topN: 10 });

        let html = "";
        const conf = (result.probability * 100).toFixed(1);
        html += `<div class="result-main">予測: <strong>${result.className}</strong> (${conf}%)</div>`;
        html += `<div class="result-score">Logit: ${result.score.toFixed(3)}</div>`;

        html += '<div class="top-predictions">';
        html += '<div class="top-predictions-title">上位10件の予測</div>';

        result.topN.forEach((item, idx) => {
          html += `<div class="prediction">`;
          html += `<span class="prediction-rank">#${idx + 1}</span>`;
          html += `<span class="prediction-name">${item.name}</span>`;
          const p = (item.probability * 100).toFixed(1);
          html += `<span class="prediction-score">${p}%</span>`;
          html += `</div>`;
        });

        html += "</div>";

        output.innerHTML = html;
      } catch (err) {
        console.error(err);
        output.innerHTML =
          '<div class="error">エラーが発生しました: ' +
          err.message +
          "</div>";
      } finally {
        predictBtn.disabled = false;
      }
    });

    // モデル読み込み開始
    window.onload = loadModel;

    loadModel();
  </script>
</body>

</html>